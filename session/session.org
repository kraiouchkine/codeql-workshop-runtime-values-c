* CodeQL Workshop --- Using Data-Flow and Range Analysis to Find Out-Of-Bounds Accesses
:PROPERTIES:
:CUSTOM_ID: codeql-workshop--using-data-flow-and-range-analysis-to-find-out-of-bounds-accesses
:END:
* Acknowledgments
  :PROPERTIES:
  :CUSTOM_ID: acknowledgments
  :END:

This session-based workshop is based on the exercise/unit-test-based material at
https://github.com/kraiouchkine/codeql-workshop-runtime-values-c, which in turn is
based on a significantly simplified and modified version of the
[[https://github.com/github/codeql-coding-standards/blob/main/c/common/src/codingstandards/c/OutOfBounds.qll][OutOfBounds.qll library]] from the
[[https://github.com/github/codeql-coding-standards][CodeQL Coding Standards
repository]]. 

* Setup Instructions
  :PROPERTIES:
  :CUSTOM_ID: setup-instructions
  :END:
- Install [[https://code.visualstudio.com/][Visual Studio Code]].

- Install the
  [[https://codeql.github.com/docs/codeql-for-visual-studio-code/setting-up-codeql-in-visual-studio-code/][CodeQL extension for Visual Studio Code]].

- Install the latest version of the
  [[https://github.com/github/codeql-cli-binaries/releases][CodeQL CLI]].

- Clone this repository:
  #+begin_src sh
  git clone https://github.com/hohn/codeql-workshop-runtime-values-c
  #+end_src

- Install the CodeQL pack dependencies using the command
  =CodeQL: Install Pack Dependencies= and select =exercises=,
  =solutions=, =exercises-tests=, =session=, =session-db= and
  =solutions-tests= from the list of packs.

- If you have CodeQL on your PATH, build the database using
  =build-database.sh= and load the database with the VS Code CodeQL
  extension. It is at =session-db/cpp-runtime-values-db=.

  - Alternatively, you can download
    [[https://drive.google.com/file/d/1N8TYJ6f4E33e6wuyorWHZHVCHBZy8Bhb/view?usp=sharing][this
    pre-built database]].

- If you do *not* have CodeQL on your PATH, build the database using the
  unit test sytem. Choose the =TESTING= tab in VS Code, run the
  =session-db/DB/db.qlref= test. The test will fail, but it leaves a
  usable CodeQL database in =session-db/DB/DB.testproj=.

- ❗Important❗: Run =initialize-qltests.sh= to initialize the tests.
  Otherwise, you will not be able to run the QLTests in
  =exercises-tests=.

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END:
This workshop focuses on analyzing and relating two values --- array
access indices and memory allocation sizes --- in order to identify
simple cases of out-of-bounds array accesses.

The following snippets demonstrate how an out-of-bounds array access can
occur:

#+begin_src cpp
char* buffer = malloc(10);
buffer[9] = 'a'; // ok
buffer[10] = 'b'; // out-of-bounds
#+end_src

A more complex example:

#+begin_src cpp
char* buffer;
if(rand() == 1) {
    buffer = malloc(10);
}
else {
    buffer = malloc(11);
}
size_t index = 0;
if(rand() == 1) {
    index = 10;
}
buffer[index]; // potentially out-of-bounds depending on control-flow
#+end_src

Another common case /not/ covered in this introductory workshop involves
loops, as follows:

#+begin_src cpp
int elements[5];
for (int i = 0; i <= 5; ++i) {
    elements[i] = 0;
}
#+end_src

To find these issues, we can implement an analysis that tracks the upper
or lower bounds on an expression and, combined with data-flow analysis
to reduce false-positives, identifies cases where the index of the array
results in an access beyond the allocated size of the buffer.

* A Note on the Scope of This Workshop
  :PROPERTIES:
  :CUSTOM_ID: a-note-on-the-scope-of-this-workshop
  :END:
This workshop is not intended to be a complete analysis that is useful
for real-world cases of out-of-bounds analyses for reasons including but
not limited to:

- Missing support for loops and recursion
- No interprocedural analysis
- Missing size calculation of arrays where the element size is not 1
- No support for pointer arithmetic or in general, operations other than
  addition and subtraction
- Overly specific modelling of a buffer access as an array expression

The goal of this workshop is rather to demonstrate the building blocks
of analyzing run-time values and how to apply those building blocks to
modelling a common class of vulnerability. A more comprehensive and
production-appropriate example is the
[[https://github.com/github/codeql-coding-standards/blob/main/c/common/src/codingstandards/c/OutOfBounds.qll][OutOfBounds.qll
library]] from the
[[https://github.com/github/codeql-coding-standards][CodeQL Coding
Standards repository]].

* Session/Workshop notes
  :PROPERTIES:
  :CUSTOM_ID: sessionworkshop-notes
  :END:

Unlike the the [[../README.md#org3b74422][exercises]] which use the /collection/ of test problems in
=exercises-test=, this workshop is a sequential session as one following the
actual process of writing CodeQL: use a /single/ database built from a single,
larger segment of code.  For this workshop, the larger segment is still simplified
skeleton code, not a full source code repository.

** Step 1
   :PROPERTIES:
   :CUSTOM_ID: exercise-1
   :END:
   In the first step we are going to start by
   1. modelling a dynamic allocation with =malloc= and
   2. an access to that allocated buffer with an
   3. array expression.

   The goal of this exercise is to then output the array access, buffer, array size,
   and buffer offset.

   The focus here is on
   : void test_const(void)
   and
   : void test_const_var(void)
   in [[file:~/local/codeql-workshop-runtime-values-c/session-db/DB/db.c][db.c]].

*** Hints
    :PROPERTIES:
    :CUSTOM_ID: hints
    :END:
1. =Expr::getValue()::toInt()= can be used to get the integer value of a
   constant expression.

*** Solution
   #+BEGIN_SRC java :tangle example1.ql
     import cpp
     import semmle.code.cpp.dataflow.DataFlow

     from AllocationExpr buffer, ArrayExpr access, int bufferSize, int accessIdx, Expr allocSizeExpr
     where
       // malloc (100)
       // ^^^^^^  AllocationExpr buffer
       //
       // buf[...]
       // ^^^  ArrayExpr access
       //
       // buf[...]
       //     ^^^  int accessIdx
       //
       accessIdx = access.getArrayOffset().getValue().toInt() and
       //
       // malloc (100)
       //         ^^^ allocSizeExpr / bufferSize
       //
       allocSizeExpr = buffer.(Call).getArgument(0) and
       bufferSize = allocSizeExpr.getValue().toInt()
     select buffer, access, accessIdx, access.getArrayOffset(), bufferSize, allocSizeExpr
   #+END_SRC

This produces 12 results, with some cross-function pairs.

** Step 2
The previous query fails to connect the =malloc= calls with the array accesses,
and =mallocs= from one function are paired with accesses in another.

To address these, take the query from the previous exercise and
1. connect the allocation(s) with the
2. array accesses

*** Hints
    :PROPERTIES:
    :CUSTOM_ID: hints
    :END:
1. Use =DataFlow::localExprFlow()= to relate the allocated buffer to the
   array base.
2. The the array base is the =buf= part of =buf[0]=.  Use the 
   =Expr.getArrayBase()= predicate.

*** Solution

    #+BEGIN_SRC java :tangle example2.ql
      import cpp
      import semmle.code.cpp.dataflow.DataFlow

      // Step 2
      // void test_const(void)
      // void test_const_var(void)
      from AllocationExpr buffer, ArrayExpr access, int bufferSize, int accessIdx, Expr allocSizeExpr
      where
        // malloc (100)
        // ^^^^^^  AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        //
        // buf[...]
        //     ^^^  int accessIdx
        //
        accessIdx = access.getArrayOffset().getValue().toInt() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        allocSizeExpr = buffer.(Call).getArgument(0) and
        bufferSize = allocSizeExpr.getValue().toInt() and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        DataFlow::localExprFlow(buffer, access.getArrayBase())
      select buffer, access, accessIdx, access.getArrayOffset(), bufferSize, allocSizeExpr
    #+END_SRC

*** Results
    There are now 3 results.  These are from only one function, the one using constants.

** Step 3
   :PROPERTIES:
   :CUSTOM_ID: exercise-2
   :END:

   The previous results need to be extended to the case
   #+BEGIN_SRC c++
     void test_const_var(void)
     {
         unsigned long size = 100;
         char *buf = malloc(size);
         buf[0];        // COMPLIANT
         ...
     }
   #+END_SRC

   Here, the =malloc= argument is a variable with known value.  

   We include this result by removing the size-retrieval from the prior query.

*** Solution

    #+BEGIN_SRC java :tangle example3.ql

      import cpp
      import semmle.code.cpp.dataflow.DataFlow

      // Step 3
      // void test_const_var(void)
      from AllocationExpr buffer, ArrayExpr access, int accessIdx, Expr allocSizeExpr
      where
        // malloc (100)
        // ^^^^^^  AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        //
        // buf[...]
        //     ^^^  int accessIdx
        //
        accessIdx = access.getArrayOffset().getValue().toInt() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        allocSizeExpr = buffer.(Call).getArgument(0) and
        // bufferSize = allocSizeExpr.getValue().toInt() and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        DataFlow::localExprFlow(buffer, access.getArrayBase())
      select buffer, access, accessIdx, access.getArrayOffset() 
    #+END_SRC

*** Results
    Now, we get 12 results, including some from other test cases.

** Step 4
   We are looking for out-of-bounds accesses, so we to need to include the
   bounds.  But in a different way.

   Note the results for the cases in =test_const_var= which involve a variable
   access rather than a constant. The next goal is to handle the case where the
   allocation size or array index are variables (with constant values) rather than
   integer constants.

   We have an expression =size= that flows into the =malloc()= call.
   
*** Solution

    #+BEGIN_SRC java :tangle example4.ql
      import cpp
      import semmle.code.cpp.dataflow.DataFlow

      // Step 4
      from AllocationExpr buffer, ArrayExpr access, int accessIdx, Expr allocSizeExpr, int bufferSize, Expr bse
      where
        // malloc (100)
        // ^^^^^^^^^^^^ AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        //
        // buf[...]
        //     ^^^  int accessIdx
        //
        accessIdx = access.getArrayOffset().getValue().toInt() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        allocSizeExpr = buffer.(Call).getArgument(0) and
        // bufferSize = allocSizeExpr.getValue().toInt() and
        //
        // unsigned long size = 100;
        // ...
        // char *buf = malloc(size);
        exists(Expr bufferSizeExpr |
          DataFlow::localExprFlow(bufferSizeExpr, buffer.getSizeExpr()) and
          bufferSizeExpr.getValue().toInt() = bufferSize
          and bse = bufferSizeExpr
        ) and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        DataFlow::localExprFlow(buffer, access.getArrayBase())
      select buffer, access, accessIdx, access.getArrayOffset(), bufferSize, bse
    #+END_SRC

*** Results
    Now, we get 15 results, limited to statically determined values.

   XX: to implement predicates
   =getSourceConstantExpr=, =getFixedSize=, and =getFixedArrayOffset= 
   Use local data-flow analysis to complete the =getSourceConstantExpr=
   predicate. The =getFixedSize= and =getFixedArrayOffset= predicates can
   be completed using =getSourceConstantExpr=.
    
XX:
   1. start with query.
      =elementSize = access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType().getSize()=
   2. convert to predicate.
   3. then use classes, if desired. =class BufferAccess extends ArrayExpr=
      is different from those below.


** Step 5 -- SimpleRangeAnalysis
   Running the query from Step 2 against the database yields a
   significant number of missing or incorrect results. The reason is that
   although great at identifying compile-time constants and their use,
   data-flow analysis is not always the right tool for identifying the
   /range/ of values an =Expr= might have, particularly when multiple
   potential constants might flow to an =Expr=.

   The range analysis already handles conditional branches; we don't
   have to use guards on data flow -- don't implement your own interpreter
   if you can use the library.

   The CodeQL standard library has several mechanisms for addressing this
   problem; in the remainder of this workshop we will explore two of them:
   =SimpleRangeAnalysis= and, later, =GlobalValueNumbering=.

   Although not in the scope of this workshop, a standard use-case for
   range analysis is reliably identifying integer overflow and validating
   integer overflow checks.

   First, simplify the =from...where...select=:
   1. Remove unnecessary =exists= clauses.
   2. Use =DataFlow::localExprFlow= for the buffer and allocation sizes, not
      =getValue().toInt()= 

   Then, add the use of the =SimpleRangeAnalysis= library.  Specifically, the
   relevant library predicates are =upperBound= and =lowerBound=, to be used with
   the buffer access argument.  Experiment and decide which to use for this
   exercise (=upperBound=, =lowerBound=, or both).

   This requires the import
   : import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis

*** Solution
    #+BEGIN_SRC java :tangle example5.ql
      import cpp
      import semmle.code.cpp.dataflow.DataFlow
      import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis

      // Step 5
      from
        AllocationExpr buffer, ArrayExpr access, Expr accessIdx, Expr allocSizeExpr, int bufferSize,
        int allocsize, Expr bufferSizeExpr
      where
        // malloc (100)
        // ^^^^^^^^^^^^ AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        //
        // buf[...]
        //     ^^^  int accessIdx
        //
        accessIdx = access.getArrayOffset() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        // Not really:
        //   allocSizeExpr = buffer.(Call).getArgument(0) and
        //
        DataFlow::localExprFlow(allocSizeExpr, buffer.(Call).getArgument(0)) and
        allocsize = allocSizeExpr.getValue().toInt() and
        //
        // unsigned long size = 100;
        // ...
        // char *buf = malloc(size);
        DataFlow::localExprFlow(bufferSizeExpr, buffer.getSizeExpr()) and
        bufferSizeExpr.getValue().toInt() = bufferSize and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        DataFlow::localExprFlow(buffer, access.getArrayBase())
      select buffer, bufferSizeExpr, access, upperBound(accessIdx) as accessMax, accessIdx, allocsize, allocSizeExpr
    #+END_SRC

*** Results
    Now, we get 48 results.

** Step 6
   To finally determine (some) out-of-bounds accesses, we have to convert
   allocation units (usually in bytes) to size units.  Then we are finally in a
   position to compare buffer allocation size to the access index to find
   out-of-bounds accesses -- at least for expressions with known values.
   
   Add these to the query:
   1. Convert allocation units to size units.
   2. Convert access units to the same size units.

   Hints:
   1. We need the size of the array element.  Use
      =access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType()=
      to see the type and 
      =access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType().getSize()=
      to get its size.

   2. Note from the docs:
      /The malloc() function allocates size bytes of memory and returns a pointer
      to the allocated memory./ 
      So =size = 1=

   3. Note that
      =allocSizeExpr.getUnspecifiedType() as allocBaseType=
      is wrong here.

   4. These test cases all use type =char=.  What would happen for =int= or
      =double=? 

*** Solution
    #+BEGIN_SRC java :tangle example6.ql
      import cpp
      import semmle.code.cpp.dataflow.DataFlow
      import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis

      // Step 6
      from
        AllocationExpr buffer, ArrayExpr access, Expr accessIdx, Expr allocSizeExpr, int bufferSize,
        int allocsize, Expr bufferSizeExpr
      where
        // malloc (100)
        // ^^^^^^^^^^^^ AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        // buf[...]
        //     ^^^  int accessIdx
        accessIdx = access.getArrayOffset() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        // Not really:
        //   allocSizeExpr = buffer.(Call).getArgument(0) and
        //
        DataFlow::localExprFlow(allocSizeExpr, buffer.(Call).getArgument(0)) and
        allocsize = allocSizeExpr.getValue().toInt() and
        //
        // unsigned long size = 100;
        // ...
        // char *buf = malloc(size);
        DataFlow::localExprFlow(bufferSizeExpr, buffer.getSizeExpr()) and
        bufferSizeExpr.getValue().toInt() = bufferSize and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        DataFlow::localExprFlow(buffer, access.getArrayBase())
      select buffer, bufferSizeExpr, access, upperBound(accessIdx) as accessMax, accessIdx, allocsize, allocSizeExpr,  access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType() as arrayBaseType, access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType().getSize() as arrayTypeSize,  1 as allocBaseSize
    #+END_SRC

*** Results
    48 results in the table

    | 1 | call to malloc | 200 | access to array | 0 | 0 | 200 | 200 | char | 1 | 1 |

** Step 7
   1. Clean up the query.
   2. Add expressions for =allocatedUnits= (from the malloc) and a
      =maxAccessedIndex= (from array accesses)
   3. Compare buffer allocation size to the access index.

*** Solution:
    #+BEGIN_SRC java :tangle example7.ql
      import cpp
      import semmle.code.cpp.dataflow.DataFlow
      import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis

      // Step 7
      from
        AllocationExpr buffer, ArrayExpr access, Expr accessIdx, Expr allocSizeExpr, int bufferSize,
        int allocsize, Expr bufferSizeExpr, int arrayTypeSize, int allocBaseSize
      where
        // malloc (100)
        // ^^^^^^^^^^^^ AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        // buf[...]
        //     ^^^  int accessIdx
        accessIdx = access.getArrayOffset() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        // Not really:
        //   allocSizeExpr = buffer.(Call).getArgument(0) and
        //
        DataFlow::localExprFlow(allocSizeExpr, buffer.(Call).getArgument(0)) and
        allocsize = allocSizeExpr.getValue().toInt() and
        //
        // unsigned long size = 100;
        // ...
        // char *buf = malloc(size);
        DataFlow::localExprFlow(bufferSizeExpr, buffer.getSizeExpr()) and
        bufferSizeExpr.getValue().toInt() = bufferSize and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        arrayTypeSize =  access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType().getSize() 
        and
        1 = allocBaseSize
        and
        DataFlow::localExprFlow(buffer, access.getArrayBase())
      select buffer, bufferSizeExpr, access, upperBound(accessIdx) as accessMax, allocSizeExpr,   allocBaseSize * allocsize as allocatedUnits, arrayTypeSize * accessMax as maxAccessedIndex
    #+END_SRC

*** Results
    48 results in the much cleaner table

    | no. | buffer         | bufferSizeExpr | access          | accessMax | allocSizeExpr | allocatedUnits | maxAccessedIndex |   |
    |  1 | call to malloc |            200 | access to array |         0 |           200 |            200 |                0 |   |

** Step 8
   1. Clean up the query.
   2. Compare buffer allocation size to the access index.
   3. Report only the questionable entries.
   4. Use
      #+BEGIN_SRC java
        /**
         ,* @kind problem
         ,*/
      #+END_SRC
      to get nicer reporting.

*** Solution:
    #+BEGIN_SRC java :tangle example8.ql
      /**
       ,* @kind problem
       ,*/

      import cpp
      import semmle.code.cpp.dataflow.DataFlow
      import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis

      // Step 8
      from
        AllocationExpr buffer, ArrayExpr access, Expr accessIdx, Expr allocSizeExpr, int bufferSize,
        int allocsize, Expr bufferSizeExpr, int arrayTypeSize, int allocBaseSize, int accessMax,
        int allocatedUnits, int maxAccessedIndex
      where
        // malloc (100)
        // ^^^^^^^^^^^^ AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        // buf[...]
        //     ^^^  int accessIdx
        accessIdx = access.getArrayOffset() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        // Not really:
        //   allocSizeExpr = buffer.(Call).getArgument(0) and
        //
        DataFlow::localExprFlow(allocSizeExpr, buffer.(Call).getArgument(0)) and
        allocsize = allocSizeExpr.getValue().toInt() and
        //
        // unsigned long size = 100;
        // ...
        // char *buf = malloc(size);
        DataFlow::localExprFlow(bufferSizeExpr, buffer.getSizeExpr()) and
        bufferSizeExpr.getValue().toInt() = bufferSize and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        arrayTypeSize = access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType().getSize() and
        1 = allocBaseSize and
        DataFlow::localExprFlow(buffer, access.getArrayBase()) and
        upperBound(accessIdx) = accessMax and
        allocBaseSize * allocsize = allocatedUnits and
        arrayTypeSize * accessMax =  maxAccessedIndex and
        // only consider out-of-bounds
        maxAccessedIndex >= allocatedUnits
      select access, "Array access at or beyond size; have "+allocatedUnits + " units, access at "+ maxAccessedIndex
    #+END_SRC

*** Results
    14 results in the much cleaner table

    | Array access at or beyond size; have 200 units, access at 200 | db.c:67:5 |
    
** Interim notes
   A common issue with the =SimpleRangeAnalysis= library is handling of
   cases where the bounds are undeterminable at compile-time on one or more
   paths. For example, even though certain paths have clearly defined
   bounds, the range analysis library will define the =upperBound= and
   =lowerBound= of =val= as =INT_MIN= and =INT_MAX= respectively:

   #+begin_src cpp
     int val = rand() ? rand() : 30;
   #+end_src

   A similar case is present in the =test_const_branch= and =test_const_branch2=
   test-cases.  In these cases, it is necessary to augment range analysis with
   data-flow and restrict the bounds to the upper or lower bound of computable
   constants that flow to a given expression.  Another approach is global value
   numbering, used next.

** Step 9 -- GlobalValueNumbering
   Range analyis won't bound =sz * x * y=, so switch to global value
   numbering.
   This is the case in the last test case, 
   #+begin_example
   void test_gvn_var(unsigned long x, unsigned long y, unsigned long sz)
   {
       char *buf = malloc(sz * x * y);
       buf[sz * x * y - 1]; // COMPLIANT
       buf[sz * x * y];     // NON_COMPLIANT
       buf[sz * x * y + 1]; // NON_COMPLIANT
   }
   #+end_example

   Reference:
   [[https://codeql.github.com/docs/codeql-language-guides/hash-consing-and-value-numbering/]] 

   Global value numbering only knows that runtime values are equal; they
   are not comparable (=<, >, <== etc.), and the /actual/ value is not
   known.

   XX: global value numbering finds expressions with the same known value,
   independent of structure.

   So, we look for and use /relative/ values between allocation and use. To do
   this, use GVN.

   The relevant CodeQL constructs are
   #+BEGIN_SRC java
     import semmle.code.cpp.valuenumbering.GlobalValueNumbering
     ...
     globalValueNumber(e) = globalValueNumber(sizeExpr) and
     e != sizeExpr
     ...
   #+END_SRC

   We can use global value numbering to identify common values as first step, but
   for expressions like
   #+begin_example
   buf[sz * x * y - 1]; // COMPLIANT
   #+end_example
   we have to "evaluate" the expressions -- or at least bound them.

*** interim
    #+BEGIN_SRC java
      /**
       ,* @ kind problem
       ,*/

      import cpp
      import semmle.code.cpp.dataflow.DataFlow
      import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
      import semmle.code.cpp.valuenumbering.GlobalValueNumbering

      // Step 9
      from
        AllocationExpr buffer, ArrayExpr access, Expr accessIdx, Expr allocSizeExpr, int bufferSize,
        int allocsize, Expr bufferSizeExpr, int arrayTypeSize, int allocBaseSize, int accessMax,
        int allocatedUnits, int maxAccessedIndex
      where
        // malloc (100)
        // ^^^^^^^^^^^^ AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        // buf[...]
        //     ^^^  int accessIdx
        accessIdx = access.getArrayOffset() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        //
        // Not really:
        //   allocSizeExpr = buffer.(Call).getArgument(0) and
        //
        DataFlow::localExprFlow(allocSizeExpr, buffer.(Call).getArgument(0)) and
        allocsize = allocSizeExpr.getValue().toInt() and
        //
        // unsigned long size = 100;
        // ...
        // char *buf = malloc(size);
        DataFlow::localExprFlow(bufferSizeExpr, buffer.getSizeExpr()) and
        bufferSizeExpr.getValue().toInt() = bufferSize and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        arrayTypeSize = access.getArrayBase().getUnspecifiedType().(PointerType).getBaseType().getSize() and
        1 = allocBaseSize and
        DataFlow::localExprFlow(buffer, access.getArrayBase()) and
        upperBound(accessIdx) = accessMax and
        allocBaseSize * allocsize = allocatedUnits and
        arrayTypeSize * accessMax = maxAccessedIndex and
        // only consider out-of-bounds
        maxAccessedIndex >= allocatedUnits
      select access,
        "Array access at or beyond size; have " + allocatedUnits + " units, access at " + maxAccessedIndex,
        globalValueNumber(accessIdx) as gvnAccess, globalValueNumber(allocSizeExpr) as gvnAlloc
    #+END_SRC

*** interim
    Messy, start over.

    #+BEGIN_SRC java

      import cpp
      import semmle.code.cpp.dataflow.DataFlow
      import semmle.code.cpp.rangeanalysis.SimpleRangeAnalysis
      import semmle.code.cpp.valuenumbering.GlobalValueNumbering

      // Step 9
      from
        AllocationExpr buffer, ArrayExpr access, Expr accessIdx, Expr allocSizeExpr, GVN gvnAccess,
        GVN gvnAlloc
      where
        // malloc (100)
        // ^^^^^^^^^^^^ AllocationExpr buffer
        //
        // buf[...]
        // ^^^  ArrayExpr access
        // buf[...]
        //     ^^^ accessIdx
        accessIdx = access.getArrayOffset() and
        //
        // malloc (100)
        //         ^^^ allocSizeExpr / bufferSize
        // unsigned long size = 100;
        // ...
        // char *buf = malloc(size);
        DataFlow::localExprFlow(allocSizeExpr, buffer.getSizeExpr()) and
        // char *buf  = ... buf[0];
        //       ^^^  --->  ^^^
        // or
        // malloc(100);   buf[0]
        // ^^^  --------> ^^^
        //
        DataFlow::localExprFlow(buffer, access.getArrayBase()) and
        //
        // Use GVN
        globalValueNumber(accessIdx) = gvnAccess and
        globalValueNumber(allocSizeExpr) = gvnAlloc and
        (
          gvnAccess = gvnAlloc
          or
          // buf[sz * x * y] above
          // buf[sz * x * y + 1];
          exists(AddExpr add |
            accessIdx = add and
            // add.getAnOperand() = accessIdx and
            add.getAnOperand().getValue().toInt() > 0 and
            globalValueNumber(add.getAnOperand()) = gvnAlloc
          )
        )
      select access, gvnAccess, gvnAlloc
    #+END_SRC
    
** TODO hashcons
import semmle.code.cpp.valuenumbering.HashCons

hashcons: every value gets a number based on structure. Fails on
#+begin_example
char *buf = malloc(sz * x * y);
sz = 100;
buf[sz * x * y - 1]; // COMPLIANT
#+end_example


The final exercise is to implement the =isOffsetOutOfBoundsGVN=
predicate to [...]
